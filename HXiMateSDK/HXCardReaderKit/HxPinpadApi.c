/* DO NOT EDIT THIS FILE - it is machine generated */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "HxPinpadApi.h"
#include "RemoteFunctions.h"

extern unsigned char gl_isHxDevice;
extern char gl_icrVersionString[50];

//Defined in HXCardReader.m
extern void _Pinpad_Cancel(void);
extern int _Pinpad_Reset(int initFlag);
extern int _Pinpad_GetVersion(unsigned char *firmwareVersion, int *versionLength);
extern int _Pinpad_DownloadMasterKey(int is3des, int index, unsigned char * masterKey, int keyLength);
extern int _Pinpad_DownloadWorkingKey(int is3des, int masterIndex, int workingIndex, unsigned char* workingKey, int keyLength);
extern int _Pinpad_InputPinblock(int is3des, int isAutoReturn, int masterIndex, int workingIndex, char* cardNo, int pinLength, unsigned char *pinblock, int timeout);

extern int _Pinpad_InputPinblockWithAmount(int is3des, int isAutoReturn, int masterIndex, int workingIndex, int amount,char* cardNo, int pinLength, unsigned char *pinblock, int timeout);

extern int _Pinpad_Mac(int is3des, int masterIndex, int workingIndex, unsigned char* data, int dataLength, unsigned char *mac);


int HxPinpad_Model(void)
{
    if (gl_isHxDevice)
        return PINPAD_MODEL_ICR;
    return PINPAD_MODEL_LIANDI;
}

void HxPinpad_Cancel(void)
{
    if (gl_isHxDevice)
        return;
    _Pinpad_Cancel();
}

int HxPinpad_Reset(int initFlag)
{
    if (gl_isHxDevice)
        return 0;
    return _Pinpad_Reset(initFlag);
}

int HxPinpad_GetVersion(unsigned char *firmwareVersion, int *versionLength)
{
    if (gl_isHxDevice) {
        if (strlen(gl_icrVersionString)) {
            strcpy(firmwareVersion, gl_icrVersionString);
            *versionLength = (int)strlen(gl_icrVersionString);
            return 0;
        }
        return 1;
    }
    return _Pinpad_GetVersion(firmwareVersion, versionLength);
}

int HxPinpad_DownloadMasterKey(int is3des, int index, unsigned char* masterKey, int keyLength)
{
    if (gl_isHxDevice) {
        if (keyLength > 16)
            keyLength = 16;
        return _uiRcEsamDownloadMasterKey(0, 0, masterKey, keyLength);
    }
    return _Pinpad_DownloadMasterKey(is3des, index, masterKey, keyLength);
}

int HxPinpad_DownloadWorkingKey(int is3des, int masterIndex, int workingIndex, unsigned char* workingKey, int keyLength)
{
    if (gl_isHxDevice) {
        if (keyLength > 16)
            keyLength = 16;
        return _uiRcEsamDownloadWorkingKey(0, 0, workingIndex%3, workingKey, keyLength);
    }
    switch (workingIndex) {
        case 0:
            workingIndex = 2; //pinkey
            break;
        case 1:
            workingIndex = 3; //mackey
            break;
        default:
            workingIndex = 0;
    }
	return _Pinpad_DownloadWorkingKey(is3des, masterIndex, workingIndex, workingKey, keyLength);
}

int HxPinpad_CalPinblock(int is3des, int masterIndex, int workingIndex, char* cardNo, unsigned char* pin, int pinLength, unsigned char *pinblock)
{
    if (!gl_isHxDevice) {
        return -1;
    }
    return  _uiRcEsamCalPinBlock(0, cardNo, 0, workingIndex%3, pin, pinLength, pinblock);
}

int HxPinpad_InputPinblock(int is3des, int isAutoReturn, int masterIndex, int workingIndex, char* cardNo, int pinLength, unsigned char *pinblock, int timeout)
{
    if (gl_isHxDevice) {
        return -1;
    }
    return _Pinpad_InputPinblock(is3des, isAutoReturn, masterIndex, workingIndex, cardNo, pinLength, pinblock, timeout);
}

int HxPinpad_InputPinblockWithAmount(int is3des, int isAutoReturn, int masterIndex, int workingIndex, int amount,char* cardNo, int pinLength, unsigned char *pinblock, int timeout)
{
    if (gl_isHxDevice) {
        return -1;
    }
    return _Pinpad_InputPinblockWithAmount(is3des, isAutoReturn, masterIndex, workingIndex, amount, cardNo, pinLength, pinblock, timeout);
}


int HxPinpad_Encrypt(int is3des, int algo, int masterIndex, int workingIndex, unsigned char *inData, int dataLength, unsigned char *outData)
{
    if ((dataLength % 8) != 0 )
        return 104;
    
    if (gl_isHxDevice) {
        return _uiRcEsamWorkingKeyEncrypt(0, 0, 0, workingIndex%3, inData, dataLength, outData);
    }
    
    int ret;
    for(int i = 0; i < dataLength/8 ; i++)
    {
        unsigned char mac[8];
        unsigned char datain[8];
        memcpy(datain, inData+8*i, 8);
        ret = _Pinpad_Mac(is3des, masterIndex, workingIndex, datain, 8, mac);
        if(ret!=0)
            return ret;
        memcpy(outData+i*8, mac, 8);
    }
    return 0;
}

static void vXor(unsigned char *pusVect1, unsigned char *pusVect2,
          unsigned int uiCnt)
{
    unsigned int i;
    
    for(i=0; i<uiCnt; i++)
        pusVect1[i]^= pusVect2[i];
}

static int macX_99(int masterIndex, int workingIndex, unsigned char *data, int dataLength, unsigned char *mac )
{
    unsigned int uiBlock, uiLength, uiRet;
    unsigned char sOutMAC[8], sBuf[8];
    
    memset(sOutMAC, 0, 8);
    uiBlock = 0;
    uiLength = dataLength;
    
    while(uiLength > uiBlock) {
        if((uiLength - uiBlock) <= 8) {
            if((uiLength - uiBlock) == 8) {
                vXor(sOutMAC, &data[uiBlock], uiLength-uiBlock);
                break;
            } else {
                memset(sBuf, 0, sizeof(sBuf));
                memcpy(sBuf, &data[uiBlock], (uiLength-uiBlock));
                vXor(sOutMAC, sBuf, 8);
                break;
            }
        }
        vXor(sOutMAC, &data[uiBlock], 8);
        uiRet = _uiRcEsamWorkingKeyEncrypt(1, 0, masterIndex, workingIndex, sOutMAC, 8, sOutMAC);
        if (uiRet)
            return uiRet;

        uiBlock += 8;
    }
    uiRet = _uiRcEsamWorkingKeyEncrypt(0, 0, masterIndex, workingIndex, sOutMAC, 8, sOutMAC);
    if (uiRet)
        return uiRet;
    memcpy(mac, sOutMAC, 8);
    
    return 0;
}

int HxPinpad_Mac(int is3des, int masterIndex, int workingIndex, unsigned char* data, int dataLength, unsigned char *mac)
{
    if (gl_isHxDevice) {
        return macX_99(0, workingIndex%3, data, dataLength, mac);
    }
    return _Pinpad_Mac(is3des, masterIndex, workingIndex, data, dataLength, mac);
}

